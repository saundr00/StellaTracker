<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>StellaTracker</title>
  <link rel="manifest" href="/manifest.json">
  <meta name="theme-color" content="#ffffff">
  <style>
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; margin: 0; padding: 0; background: #fafafa; color: #111; }
    header { position: sticky; top: 0; background: #fff; border-bottom: 1px solid #eee; padding: 12px 16px; display:flex; gap:12px; align-items:center; }
    header img { width: 28px; height: 28px; border-radius: 6px; background:#ddd; }
    h1 { font-size: 18px; margin: 0; }
    main { padding: 16px; display:grid; gap: 16px; max-width: 900px; margin: 0 auto; }
    .card { background: #fff; border: 1px solid #eee; border-radius: 12px; padding: 12px; box-shadow: 0 1px 2px rgba(0,0,0,0.04); }
    .row { display: grid; grid-template-columns: 1fr 1fr; gap: 8px; }
    label { font-size: 14px; display:block; margin: 6px 0; }
    input, select, textarea, button { font-size: 16px; padding: 10px; border: 1px solid #ddd; border-radius: 8px; width: 100%; box-sizing: border-box; background:#fff;}
    button { cursor: pointer; border-color: #ccc; }
    .grid { display:grid; gap:8px; }
    .muted { color:#666; font-size:12px; }
    .entries { display:grid; gap:8px; }
    .entry { padding:10px; border:1px solid #eee; border-radius:8px; background:#fff; }
    .pill { display:inline-block; padding:2px 8px; border-radius:999px; font-size:12px; background:#efefef; margin-right:6px; }
    .flex { display:flex; gap:8px; align-items:center; flex-wrap: wrap; }
    .space { height:4px; }
    .danger { color:#b00020; }
    .iconbtn { border: none; background: transparent; cursor: pointer; font-size: 16px; padding: 4px 6px; }
    .preset { padding:8px 10px; border:1px solid #ddd; border-radius:999px; background:#f7f7f7; }
    .history-row { display:grid; grid-template-columns: 200px 1fr 80px; gap:8px; align-items:center; }
    .history-row h3 { margin:0; font-size:14px; font-weight:600; }
    .spark { color:#333; }
    .spark svg { display:block; width:100%; height:28px; }
    .mono { font-variant-numeric: tabular-nums; font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; text-align:right; }
  </style>
</head>
<body>
  <header>
    <img alt="logo" />
    <h1>StellaTracker</h1>
  </header>
  <main>
    <section class="card">
      <h2 style="margin:0 0 8px 0;">Quick Presets</h2>
      <div class="flex" id="presets"></div>
    </section>

    <section class="card">
      <h2 style="margin:0 0 8px 0;">Add Log Entry</h2>
      <div class="grid">
        <div class="row">
          <div>
            <label for="metric">Metric</label>
            <select id="metric"></select>
          </div>
          <div>
            <label for="value">Value</label>
            <input id="value" placeholder="e.g., duration 10min, dose 250mg, distance 0.1mi…" />
          </div>
        </div>

        <div class="row" id="accidentRow" style="display:none;">
          <div>
            <label for="location">Accident Location</label>
            <select id="location">
              <option value="">(none)</option>
              <option value="bed">Bed</option>
              <option value="couch">Couch</option>
              <option value="deck">Deck</option>
              <option value="yard">Yard</option>
              <option value="other">Other</option>
            </select>
          </div>
          <div>
            <label for="severity">Severity/Size (optional)</label>
            <input id="severity" placeholder="e.g., small/medium/large" />
          </div>
        </div>

        <div id="energyRow" style="display:none;">
          <label for="energy">Energy Level</label>
          <input id="energy" type="range" min="0" max="5" step="1" value="3">
        </div>

        <label for="note">Note (optional)</label>
        <textarea id="note" rows="2" placeholder="Short note…"></textarea>
        <div class="row">
          <div>
            <label for="ts">Time</label>
            <input id="ts" type="datetime-local" />
          </div>
          <div style="display:flex; align-items:flex-end; gap:8px;">
            <button id="saveBtn">Save Entry</button>
            <button id="flushBtn">Sync Pending</button>
          </div>
        </div>
        <div class="muted">Works offline. If the network fails, entries are queued and will sync when you tap <b>Sync Pending</b> or come back online.</div>
      </div>
    </section>

    <section class="card">
      <div class="flex" style="justify-content:space-between;">
        <h2 id="entriesHeader" style="margin:0;">Entries (last 30 days)</h2>
        <div class="flex">
          <button id="refreshBtn">Refresh</button>
          <button id="exportBtn">Export CSV</button>
        </div>
      </div>
      <div id="todayCounts" class="grid muted"></div>
      <div class="space"></div>
      <div id="entries" class="entries"></div>
    </section>

    <section class="card">
      <div class="flex" style="justify-content:space-between; align-items:center;">
        <h2 style="margin:0;">History</h2>
        <select id="historyRange">
          <option value="7">Last 7 days</option>
          <option value="30" selected>Last 30 days</option>
          <option value="90">Last 90 days</option>
        </select>
      </div>
      <div id="historyList" class="grid"></div>
    </section>
  </main>

  <script>
    const apiBase = "/api"; // SWA managed functions
    const pendingKey = "st_pending_entries";

    const metricEl = document.getElementById("metric");
    const valueEl = document.getElementById("value");
    const noteEl = document.getElementById("note");
    const tsEl = document.getElementById("ts");
    const entriesEl = document.getElementById("entries");
    const todayCountsEl = document.getElementById("todayCounts");
    const saveBtn = document.getElementById("saveBtn");
    const refreshBtn = document.getElementById("refreshBtn");
    const exportBtn = document.getElementById("exportBtn");
    const flushBtn = document.getElementById("flushBtn");
    const presetsEl = document.getElementById("presets");
    const accidentRow = document.getElementById("accidentRow");
    const energyRow = document.getElementById("energyRow");
    const energySlider = document.getElementById("energy");
    const locationEl = document.getElementById("location");
    const severityEl = document.getElementById("severity");

    function setNow() {
      const now = new Date();
      const tzOffset = now.getTimezoneOffset();
      const local = new Date(now.getTime() - tzOffset*60000);
      tsEl.value = local.toISOString().slice(0,16);
    }

    // --- Dynamic config (external) ---
    let CONFIG = null;
    let metricMap = new Map();

    async function loadConfig() {
      try {
        const res = await fetch('./config.json', { cache: 'no-store' });
        if (!res.ok) throw new Error(`HTTP ${res.status}`);
        CONFIG = await res.json();
        console.info('[config] Loaded ./config.json');
      } catch (err) {
        console.warn('[config] Could not load ./config.json; using built-in defaults.', err);
        CONFIG = {
          metrics: [
            { id: 'stand_assisted', label: 'Stand (Assisted)' },
            { id: 'stand_unassisted', label: 'Stand (Unassisted)' },
            { id: 'drink', label: 'Drink Water' },
            { id: 'eat', label: 'Eat' },
            { id: 'notes', label: 'Notes' }
          ],
          presets: [
            { label: '+1 Stand (Unassisted)',       metric: 'stand_unassisted',      value: '+1', note: '' },
            { label: '+1 Walk Inside (Unassisted)', metric: 'walk_inside_unassisted', value: '+1', note: '' },
            { label: '+1 Panting',                   metric: 'panting',               value: '+1', note: '' },
            { label: '+1 Drink Water',               metric: 'drink',                 value: '+1', note: '' }
          ]
        };
      }

      metricMap = new Map(CONFIG.metrics.map(m => [m.id, m]));
      buildMetricSelect();
      buildPresets();
      onMetricChange();
    }

    function buildMetricSelect() {
      metricEl.innerHTML = '';
      for (const m of CONFIG.metrics) {
        const opt = document.createElement('option');
        opt.value = m.id;
        opt.textContent = m.label;
        metricEl.appendChild(opt);
      }
    }

    function buildPresets() {
      presetsEl.innerHTML = '';
      for (const p of (CONFIG.presets || [])) {
        const btn = document.createElement('button');
        btn.className = 'preset';
        btn.dataset.metric = p.metric;
        if (p.value != null) btn.dataset.value = String(p.value);
        if (p.note != null) btn.dataset.note = String(p.note);
        btn.textContent = p.label;
        presetsEl.appendChild(btn);
      }
    }

    setNow();
    loadConfig();

    metricEl.addEventListener("change", onMetricChange);
    function onMetricChange() {
      const id = metricEl.value;
      const def = metricMap.get(id) || {};
      // Accident-specific extras come from config
      accidentRow.style.display = def.showAccidentExtras ? '' : 'none';
      // Energy slider driven by config
      if (def.energyScale) {
        energyRow.style.display = '';
        energySlider.min = def.energyScale.min ?? 0;
        energySlider.max = def.energyScale.max ?? 5;
        energySlider.step = def.energyScale.step ?? 1;
        if (!valueEl.value) {
          energySlider.value = String(def.energyScale.default ?? 3);
          valueEl.value = String(def.energyScale.default ?? 3);
        }
      } else {
        energyRow.style.display = 'none';
      }
    }

    presetsEl.addEventListener("click", (e) => {
      const btn = e.target.closest("button.preset");
      if (!btn) return;
      metricEl.value = btn.dataset.metric;
      valueEl.value = btn.dataset.value || "";
      noteEl.value = btn.dataset.note || "";
      onMetricChange();
      saveEntry();
    });

    function fmtDate(s) {
      const d = new Date(s);
      return d.toLocaleString();
    }
    function pill(label) {
      const span = document.createElement("span");
      span.className = "pill";
      span.textContent = label;
      return span;
    }

    // ─────────────────────────────────────────────────────────────────────────────
    // History helpers: rollups and sparklines
    function isoDay(d) { return d.toISOString().slice(0,10); }
    function daysArray(n) {
      const out = [];
      const now = new Date();
      const end = new Date(Date.UTC(now.getUTCFullYear(), now.getUTCMonth(), now.getUTCDate()));
      for (let i = n - 1; i >= 0; i--) {
        const dt = new Date(end); dt.setUTCDate(end.getUTCDate() - i);
        out.push(isoDay(dt));
      }
      return out; // array of YYYY-MM-DD
    }

    function rollupCountsByDay(items) {
      const byDay = new Map();
      for (const e of (items || [])) {
        const key = new Date(e.ts).toISOString().slice(0,10);
        if (!byDay.has(key)) byDay.set(key, {});
        const bucket = byDay.get(key);
        bucket[e.metric] = (bucket[e.metric] || 0) + 1;
      }
      return byDay; // Map(date -> {metric:count})
    }

    function seriesForMetric(metricId, days, byDay) {
      const vals = [];
      for (const d of days) {
        const bucket = byDay.get(d) || {};
        vals.push(bucket[metricId] || 0);
      }
      return vals;
    }

    function sparklineSVG(values, w = 180, h = 28) {
      if (!values.length) return "";
      const max = Math.max(...values), min = Math.min(...values);
      const sx = (i) => (values.length === 1) ? 1 : (i / (values.length - 1)) * (w - 2) + 1;
      const sy = (v) => {
        if (max === min) return h / 2; // flat line when constant
        return h - 1 - ((v - min) / (max - min)) * (h - 2);
      };
      const pts = values.map((v,i)=>`${sx(i)},${sy(v)}`).join(" ");
      const last = values[values.length - 1];
      return `<svg viewBox="0 0 ${w} ${h}"><polyline fill="none" stroke="currentColor" stroke-width="2" points="${pts}"/><circle cx="${sx(values.length-1)}" cy="${sy(last)}" r="2" /></svg>`;
    }

    const historyRangeEl = document.getElementById('historyRange');
    const historyListEl = document.getElementById('historyList');

    function updateEntriesHeader() {
      const days = parseInt(historyRangeEl.value || '30', 10);
      const h = document.getElementById('entriesHeader');
      if (h) h.textContent = `Entries (last ${days} days)`;
    }

    async function loadHistory() {
      const days = parseInt(historyRangeEl.value || '30', 10);
      const now = new Date();
      const from = new Date(now.getFullYear(), now.getMonth(), now.getDate() - days + 1);
      const params = new URLSearchParams({ from: from.toISOString(), to: now.toISOString() });
      const res = await fetch(`${apiBase}/entries?${params.toString()}`);
      if (!res.ok) { historyListEl.innerHTML = "<div class='muted'>Failed to load history.</div>"; return; }
      const data = await res.json();
      renderHistory(data.items || [], days);
    }

    function renderHistory(items, daysBack) {
      const days = daysArray(daysBack);
      const byDay = rollupCountsByDay(items);

      // Compute totals per metric over the window
      const totals = new Map();
      for (const e of (items || [])) {
        totals.set(e.metric, (totals.get(e.metric) || 0) + 1);
      }

      // Build list of metrics from CONFIG, excluding purely textual ones if desired
      const metricIds = (CONFIG.metrics || []).map(m => m.id);
      // Sort by activity (total desc) and take top 8 to keep UI compact
      const top = metricIds
        .filter(id => totals.get(id) > 0)
        .sort((a,b) => (totals.get(b)||0) - (totals.get(a)||0))
        .slice(0, 8);

      historyListEl.innerHTML = '';
      if (top.length === 0) {
        historyListEl.innerHTML = "<div class='muted'>No history for this period.</div>";
        return;
      }

      for (const id of top) {
        const def = metricMap.get(id) || { label: id };
        const series = seriesForMetric(id, days, byDay);
        const last = series.length ? series[series.length - 1] : 0;
        const row = document.createElement('div');
        row.className = 'history-row';

        const name = document.createElement('h3');
        name.textContent = def.label || id;
        row.appendChild(name);

        const spark = document.createElement('div');
        spark.className = 'spark';
        spark.innerHTML = sparklineSVG(series);
        row.appendChild(spark);

        const lastDiv = document.createElement('div');
        lastDiv.className = 'mono';
        lastDiv.textContent = String(last);
        row.appendChild(lastDiv);

        historyListEl.appendChild(row);
      }
    }

    // Hook range changes
    historyRangeEl.addEventListener('change', () => {
      updateEntriesHeader();
      loadHistory();
      refresh();
    });

    function loadPending() {
      try {
        return JSON.parse(localStorage.getItem(pendingKey) || "[]");
      } catch { return []; }
    }
    function savePending(arr) {
      localStorage.setItem(pendingKey, JSON.stringify(arr));
    }
    async function flushPending() {
      const queue = loadPending();
      if (!queue.length) return;
      const remain = [];
      for (const body of queue) {
        try {
          const res = await fetch(`${apiBase}/entry`, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify(body)
          });
          if (!res.ok) throw new Error("fail");
        } catch {
          remain.push(body);
        }
      }
      savePending(remain);
      await refresh();
      alert(remain.length ? `Synced ${queue.length - remain.length}, ${remain.length} left` : `All pending entries synced`);
    }
    window.addEventListener("online", flushPending);
    setInterval(flushPending, 30000);

    async function saveEntry() {
      const metric = metricEl.value;
      let value = valueEl.value || '';
      const noteParts = [];
      const def = metricMap.get(metric) || {};
      if (def.energyScale) {
        value = energySlider.value;
      }
      if (def.showAccidentExtras) {
        if (locationEl.value) noteParts.push(`location:${locationEl.value}`);
        if (severityEl.value) noteParts.push(`size:${severityEl.value}`);
      }
      const extra = noteParts.join(' ');
      const note = [noteEl.value || '', extra].filter(Boolean).join(' ').trim();
      const localIso = new Date(tsEl.value).toISOString();
      const body = { metric, value, note, ts: localIso };

      try {
        const res = await fetch(`${apiBase}/entry`, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify(body)
        });
        if (!res.ok) throw new Error("save failed");
      } catch {
        // queue offline
        const q = loadPending();
        q.push(body);
        savePending(q);
      }
      valueEl.value = "";
      noteEl.value = "";
      locationEl.value = "";
      severityEl.value = "";
      setNow();
      await refresh();
    }

    async function deleteEntry(partitionKey, rowKey) {
      if (!confirm("Delete this entry?")) return;
      const res = await fetch(`${apiBase}/entry/${encodeURIComponent(partitionKey)}/${encodeURIComponent(rowKey)}`, {
        method: "DELETE"
      });
      if (!res.ok) {
        alert("Failed to delete.");
        return;
      }
      await refresh();
    }

    function summarizeToday(entries) {
      const start = new Date(); start.setHours(0,0,0,0);
      const end = new Date(); end.setHours(23,59,59,999);
      const today = entries.filter(e => {
        const t = new Date(e.ts);
        return t >= start && t <= end;
      });
      const counts = {};
      for (const e of today) {
        counts[e.metric] = (counts[e.metric] || 0) + 1;
      }
      todayCountsEl.innerHTML = "";
      const keys = Object.keys(counts).sort();
      if (keys.length === 0) {
        const div = document.createElement("div");
        div.textContent = "No entries yet today.";
        todayCountsEl.appendChild(div);
      } else {
        for (const k of keys) {
          const div = document.createElement("div");
          div.textContent = `${k}: ${counts[k]}`;
          todayCountsEl.appendChild(div);
        }
      }
    }

    async function refresh() {
      const params = new URLSearchParams();
      const now = new Date();
      const start = new Date(now.getFullYear(), now.getMonth(), now.getDate() - 30);
      params.set("from", start.toISOString());
      params.set("to", now.toISOString());
      const res = await fetch(`${apiBase}/entries?${params.toString()}`);
      if (!res.ok) { entriesEl.innerHTML = "<div class='muted'>Failed to load.</div>"; return; }
      const data = await res.json();
      entriesEl.innerHTML = "";
      summarizeToday(data.items || []);
      (data.items || []).sort((a,b) => a.ts > b.ts ? -1 : 1).forEach(e => {
        const div = document.createElement("div");
        div.className = "entry";
        const h = document.createElement("div");
        h.appendChild(pill(e.metric));
        if (e.value) h.appendChild(pill(e.value));
        div.appendChild(h);
        const t = document.createElement("div");
        t.className = "muted";
        t.textContent = fmtDate(e.ts);
        div.appendChild(t);
        if (e.note) {
          const n = document.createElement("div");
          n.textContent = e.note;
          div.appendChild(n);
        }
        const actions = document.createElement("div");
        actions.className = "flex";
        const del = document.createElement("button");
        del.className = "iconbtn danger";
        del.textContent = "Delete";
        del.addEventListener("click", () => deleteEntry(e.partitionKey, e.id));
        actions.appendChild(del);
        div.appendChild(actions);
        entriesEl.appendChild(div);
      });
    }

    saveBtn.addEventListener("click", saveEntry);
    refreshBtn.addEventListener("click", refresh);
    exportBtn.addEventListener("click", async () => {
      const res = await fetch(`${apiBase}/export?days=30`);
      if (!res.ok) { alert("Failed to export"); return; }
      const blob = await res.blob();
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      a.download = "stella_export.csv";
      document.body.appendChild(a);
      a.click();
      a.remove();
      URL.revokeObjectURL(url);
    });
    flushBtn.addEventListener("click", flushPending);

    refresh();
    loadHistory();
    updateEntriesHeader();
  </script>
</body>
</html>
